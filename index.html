<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Tetris with piece queue, cache, and cycling</title>
<style>
  @keyframes pulse {
    0% { transform: scale(1); filter: brightness(1); }
    50% { transform: scale(1.02); filter: brightness(1.2); }
    100% { transform: scale(1); filter: brightness(1); }
  }

  @keyframes gradient {
    0% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
    100% { background-position: 0% 50%; }
  }

  @keyframes glow {
    0% { text-shadow: 0 0 5px rgba(255, 165, 0, 0.5); }
    50% { text-shadow: 0 0 10px rgba(255, 165, 0, 0.8); }
    100% { text-shadow: 0 0 5px rgba(255, 165, 0, 0.5); }
  }

  .progress-bar {
    width: 200px;
    height: 24px;
    background: #222;
    border: 2px solid #FFA500;
    border-radius: 12px;
    overflow: hidden;
    position: relative;
    margin: 10px auto;
    box-shadow: 0 0 10px rgba(255, 165, 0, 0.2);
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    justify-content: center;
    align-items: center;
  }

  .progress-bar:hover {
    transform: scale(1.02);
    box-shadow: 0 0 15px rgba(255, 165, 0, 0.4);
  }

  .progress-bar .fill {
    height: 100%;
    background: linear-gradient(45deg, #FF4500, #FFA500, #FFD700);
    background-size: 200% 200%;
    animation: gradient 3s ease infinite;
    transition: width 0.3s ease-out;
    border-radius: 8px;
  }

  .progress-bar .text {
    position: absolute;
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    font-family: monospace;
    font-weight: bold;
    font-size: 16px;
    letter-spacing: 1px;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
    z-index: 1;
    animation: glow 2s ease-in-out infinite;
    text-align: center;
    padding: 0;
    left: 0;
    right: 0;
  }

  #explosion-bar.ready .fill {
    background: linear-gradient(45deg, #FF4500, #FFA500, #FFD700, #FF4500);
    background-size: 200% 200%;
    animation: gradient 2s ease infinite, pulse 1.5s infinite;
    filter: brightness(1.2);
  }

  #explosion-bar.ready .text {
    color: #FFD700;
    font-size: 17px;
    text-shadow: 0 0 5px rgba(255, 215, 0, 0.8);
  }

  #explosion-bar:not(.ready) .fill {
    filter: brightness(0.8);
  }

  body {
    background: #000;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    margin: 0;
    color: white;
    font-family: monospace;
  }
  canvas {
    background: black;
    border: 2px solid white;
    display: block;
  }
  #info {
    text-align: center;
    margin-bottom: 6px;
  }
  #start-screen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.9);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 1000;
  }
  #start-screen h1 {
    font-size: 48px;
    margin-bottom: 30px;
    color: #FFA500;
    text-shadow: 0 0 10px rgba(255, 165, 0, 0.5);
    animation: glow 2s ease-in-out infinite;
  }
  #start-screen button {
    font-size: 24px;
    padding: 15px 40px;
    background: transparent;
    color: white;
    border: 2px solid #FFA500;
    cursor: pointer;
    transition: all 0.3s ease;
    font-family: monospace;
  }
  #start-screen button:hover {
    background: #FFA500;
    color: black;
    transform: scale(1.1);
  }
  @keyframes glow {
    0% { text-shadow: 0 0 10px rgba(255, 165, 0, 0.5); }
    50% { text-shadow: 0 0 20px rgba(255, 165, 0, 0.8); }
    100% { text-shadow: 0 0 10px rgba(255, 165, 0, 0.5); }
  }
  
  .settings-button {
    position: fixed;
    top: 20px;
    right: 20px;
    background: transparent;
    border: 2px solid #FFA500;
    color: white;
    padding: 10px 20px;
    cursor: pointer;
    font-family: monospace;
    z-index: 1001;
  }
  
  .settings-panel {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.95);
    border: 2px solid #FFA500;
    padding: 20px;
    z-index: 1002;
    min-width: 300px;
    display: none;
  }
  
  .settings-panel h2 {
    color: #FFA500;
    margin-top: 0;
    margin-bottom: 20px;
    text-align: center;
  }
  
  .settings-option {
    margin-bottom: 15px;
  }
  
  .settings-option label {
    display: block;
    margin-bottom: 5px;
    color: white;
  }
  
  .settings-option select {
    width: 100%;
    padding: 5px;
    background: black;
    color: white;
    border: 1px solid #FFA500;
  }
  
  .settings-option input[type="checkbox"] {
    margin-right: 10px;
  }
  
  .settings-close {
    position: absolute;
    top: 10px;
    right: 10px;
    background: transparent;
    border: none;
    color: white;
    cursor: pointer;
    font-size: 20px;
  }
  
  .ghost-piece {
    opacity: 0.3;
  }

  #score-display {
    position: relative;
    font-size: 36px;
    color: #FFA500;
    text-shadow: 0 0 10px rgba(255, 165, 0, 0.5);
    font-family: monospace;
    margin-bottom: 10px;
  }

  #level-notification {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.9);
    border: 2px solid #FFA500;
    color: #FFA500;
    padding: 20px 40px;
    font-size: 24px;
    font-family: monospace;
    z-index: 1000;
    opacity: 0;
    transition: opacity 0.3s ease;
    pointer-events: none;
  }
</style>
</head>
<body>
<div id="level-notification"></div>
<button class="settings-button" onclick="toggleSettings()">⚙️ Settings</button>
<div class="settings-panel" id="settings-panel">
  <button class="settings-close" onclick="toggleSettings()">×</button>
  <h2>Settings</h2>
  <div class="settings-option">
    <label for="game-speed">Game Speed:</label>
    <select id="game-speed" onchange="updateGameSpeed()">
      <option value="1000">Slow</option>
      <option value="500">Quick</option>
      <option value="200">Fast</option>
    </select>
  </div>
  <div class="settings-option">
    <label>
      <input type="checkbox" id="ghost-toggle" onchange="toggleGhostPiece()" checked>
      Show Ghost Piece
    </label>
  </div>
</div>
<div id="start-screen">
  <h1>TETRIS</h1>
  <div style="margin-bottom: 20px; text-align: center;">
    <label style="color: #FFA500; display: block; margin-bottom: 10px;">Game Mode:</label>
    <div style="display: flex; justify-content: center; gap: 10px;">
      <button id="regular-mode" onclick="selectMode('regular')" style="background: #FFA500; color: black; border: none; padding: 10px 20px; font-size: 18px; font-family: monospace; cursor: pointer; transition: all 0.3s ease;">Regular</button>
      <button id="challenge-mode" onclick="selectMode('challenge')" style="background: transparent; color: #FFA500; border: 2px solid #FFA500; padding: 10px 20px; font-size: 18px; font-family: monospace; cursor: pointer; transition: all 0.3s ease;">Challenge</button>
    </div>
  </div>
  <div id="level-selection" style="margin-bottom: 20px; text-align: center; display: none;">
    <label for="level-select" style="color: #FFA500; display: block; margin-bottom: 10px;">Select Starting Level:</label>
    <select id="level-select" style="background: black; color: white; border: 2px solid #FFA500; padding: 5px 10px; font-size: 18px; font-family: monospace;">
      <option value="1">Level 1 - Normal</option>
      <option value="2">Level 2 - Split Arena</option>
      <option value="3">Level 3 - Checkerboard</option>
      <option value="4">Level 4 - Triple Split</option>
      <option value="5">Level 5 - Maze</option>
      <option value="6">Level 6 - Spiral</option>
      <option value="7">Level 7 - Diamond</option>
      <option value="8">Level 8 - Zigzag</option>
      <option value="9">Level 9 - Cross</option>
      <option value="10">Level 10 - Final Challenge</option>
    </select>
  </div>
  <button onclick="startGame()">START GAME</button>
</div>
<div style="display: flex; flex-direction: column; align-items: center;">
  <div id="score-display">SCORE: 0</div>
  <div style="display: flex; justify-content: center; align-items: flex-end; gap: 40px; margin-bottom: 8px;">
    <div style="text-align: center;">
      <div>Cached Block:</div>
      <canvas id="cached" width="80" height="80"></canvas>
    </div>
    <div style="text-align: center;">
      <div>Next Block:</div>
      <canvas id="next" width="80" height="80"></canvas>
    </div>
  </div>
  <canvas id="tetris" width="200" height="440" style="margin-bottom: 12px;"></canvas>
  <div style="width: 100%; text-align: center;">
    <div class="progress-bar" id="level-bar" style="margin-bottom: 12px; display: none;">
      <div class="fill" style="width: 0%"></div>
      <div class="text">
        <span id="level-text">Level 1 - 0/5 lines</span>
      </div>
    </div>
  </div>
  <div style="width: 100%; text-align: center;">
    <div id="explosion-bar" class="progress-bar" style="cursor: pointer;" onclick="if(explosionAvailable) shootDownAndClearTop()" title="Clear 30 lines to activate explosion">
    <div class="fill" style="width: 0%"></div>
    <div class="text">
      <span id="lines-text">0/30 lines</span>
    </div>
  </div>
  <div id="info">
    <div>
      Controls: ← → ↓ to move/drop, ↑ to rotate, C to cache/swap, Space for hard drop, L to discard cached (once), D for explosion
    </div>
  </div>
</div>
<script>
  const canvas = document.getElementById('tetris');
  const ctx = canvas.getContext('2d');
  ctx.scale(20, 20);

  // Cached and next block canvases
  const cachedCanvas = document.getElementById('cached');
  const cachedCtx = cachedCanvas.getContext('2d');
  cachedCtx.scale(20, 20);

  const nextCanvas = document.getElementById('next');
  const nextCtx = nextCanvas.getContext('2d');
  nextCtx.scale(20, 20);

  const initialWidth = 10;
  const initialHeight = 20;
  let arenaWidth = initialWidth;
  let arenaHeight = initialHeight;
  let arenaOffset = 0;
  
  let score = 0;
  let level = 1;
  let linesForNextLevel = 5;
  
  const levelConfig = {
    1: { 
      width: 10, 
      height: 20,
      scoreTarget: 1000,
      setupGrid: function(arena) {} // Normal grid
    },
    2: { 
      width: 30, 
      height: 20,
      scoreTarget: 1000,
      setupGrid: function(arena) {
        // Create walls in the middle
        for (let y = 5; y < 15; y++) {
          arena[y][14] = 8; // Wall piece
          arena[y][15] = 8;
        }
      }
    },
    3: { 
      width: 30, 
      height: 20,
      scoreTarget: 1000,
      setupGrid: function(arena) {
        // Checkerboard pattern obstacles
        for (let y = 10; y < 20; y += 2) {
          for (let x = 5; x < 25; x += 4) {
            arena[y][x] = 8;
          }
        }
      }
    },
    4: { 
      width: 30, 
      height: 20,
      scoreTarget: 1000,
      setupGrid: function(arena) {
        // Three vertical walls
        for (let y = 5; y < 15; y++) {
          arena[y][8] = 8;
          arena[y][15] = 8;
          arena[y][22] = 8;
        }
      }
    },
    5: { 
      width: 30, 
      height: 20,
      scoreTarget: 1000,
      setupGrid: function(arena) {
        // Maze-like pattern
        for (let y = 5; y < 15; y += 3) {
          for (let x = 5; x < 25; x++) {
            arena[y][x] = 8;
          }
          arena[y][10] = 0;
          arena[y][20] = 0;
        }
      }
    },
    6: {
      width: 30,
      height: 20,
      scoreTarget: 1000,
      setupGrid: function(arena) {
        // Spiral pattern
        const center = { x: Math.floor(arena[0].length / 2), y: Math.floor(arena.length / 2) };
        for (let i = 0; i < 10; i++) {
          arena[center.y + i][center.x] = 8;
          arena[center.y][center.x + i] = 8;
          arena[center.y - i][center.x] = 8;
          arena[center.y][center.x - i] = 8;
        }
      }
    },
    7: {
      width: 30,
      height: 20,
      scoreTarget: 1000,
      setupGrid: function(arena) {
        // Diamond pattern
        for (let y = 0; y < arena.length; y++) {
          for (let x = 0; x < arena[0].length; x++) {
            if ((x + y) % 4 === 0 && x > 5 && x < arena[0].length - 5 && y > 5) {
              arena[y][x] = 8;
            }
          }
        }
      }
    },
    8: {
      width: 30,
      height: 20,
      scoreTarget: 1000,
      setupGrid: function(arena) {
        // Zigzag walls
        for (let y = 5; y < arena.length - 5; y++) {
          const offset = Math.floor(y / 3) % 2 === 0 ? 10 : 20;
          arena[y][offset] = 8;
        }
      }
    },
    9: {
      width: 30,
      height: 20,
      scoreTarget: 1000,
      setupGrid: function(arena) {
        // Cross pattern
        const center = { x: Math.floor(arena[0].length / 2), y: Math.floor(arena.length / 2) };
        for (let i = -5; i <= 5; i++) {
          if (center.x + i >= 0 && center.x + i < arena[0].length) {
            arena[center.y][center.x + i] = 8;
          }
          if (center.y + i >= 0 && center.y + i < arena.length) {
            arena[center.y + i][center.x] = 8;
          }
        }
      }
    },
    10: {
      width: 30,
      height: 20,
      scoreTarget: 1000,
      setupGrid: function(arena) {
        // Final challenge: Multiple patterns combined
        // Corners
        for (let i = 0; i < 5; i++) {
          arena[i][i] = 8;
          arena[i][arena[0].length - 1 - i] = 8;
          arena[arena.length - 1 - i][i] = 8;
          arena[arena.length - 1 - i][arena[0].length - 1 - i] = 8;
        }
        // Center cross
        const center = { x: Math.floor(arena[0].length / 2), y: Math.floor(arena.length / 2) };
        arena[center.y][center.x] = 8;
        arena[center.y - 1][center.x] = 8;
        arena[center.y + 1][center.x] = 8;
        arena[center.y][center.x - 1] = 8;
        arena[center.y][center.x + 1] = 8;
      }
    }
  };
  function expandArena() {
    // Add 10 columns to both sides
    const newColumns = 10;
    arenaOffset += newColumns;
    
    // Create random 4 rows template that will be used for both sides
    const createRandomRows = () => {
      const rows = [];
      for (let i = 0; i < 4; i++) {
        const row = new Array(newColumns).fill(0);
        // Fill about 60% of the cells with random pieces
        for (let j = 0; j < newColumns; j++) {
          if (Math.random() < 0.6) {
            row[j] = Math.floor(Math.random() * 7) + 1;
          }
        }
        rows.push(row);
      }
      return rows;
    };

    // Create random rows for both sides
    const leftRandomRows = createRandomRows();
    const rightRandomRows = createRandomRows();

    // Create new empty arena with expanded width
    const oldArena = [...arena];
    arena.length = 0;
    
    // Initialize new expanded arena
    const fullWidth = arenaWidth + (newColumns * 2);
    for (let i = 0; i < arenaHeight; i++) {
      arena.push(new Array(fullWidth).fill(0));
    }
    
    // Copy the original arena content to the center
    for (let y = 0; y < arenaHeight; y++) {
      for (let x = 0; x < arenaWidth; x++) {
        arena[y][x + newColumns] = oldArena[y][x];
      }
    }
    
    // Add random blocks at the bottom 4 rows on both sides using the same method
    for (let y = arenaHeight - 4; y < arenaHeight; y++) {
      const rowIndex = y - (arenaHeight - 4);
      
      // Add left side random blocks
      for (let x = 0; x < newColumns; x++) {
        arena[y][x] = leftRandomRows[rowIndex][x];
      }
      
      // Add right side random blocks
      for (let x = 0; x < newColumns; x++) {
        arena[y][arenaWidth + newColumns + x] = rightRandomRows[rowIndex][x];
      }
    }

  // Update the canvas size only (do not scale or translate here)
  canvas.width = fullWidth * 20;
  // Scaling and translation will be handled in draw()
  }

  // Arena grid
  function createArena(width, height) {
    const newArena = [];
    for (let i = 0; i < height; i++) {
      newArena.push(new Array(width).fill(0));
    }
    return newArena;
  }

  function switchToLevel2Arena() {
    arenaWidth = 30;
    arenaHeight = 20;
    
    // Create new arena with new dimensions
    const newArena = createArena(arenaWidth, arenaHeight);
    
    // Clear the old arena
    arena.length = 0;
    arena.push(...newArena);
    
    // Update canvas size
    canvas.width = arenaWidth * 20;
    canvas.height = arenaHeight * 20;
    
    // Reset player position
    playerReset();
    
    // Update the scale to maintain block size
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.scale(20, 20);
  }

  function switchToLevel1Arena() {
    arenaWidth = initialWidth;
    arenaHeight = initialHeight;
    
    // Create new arena with original dimensions
    const newArena = createArena(arenaWidth, arenaHeight);
    
    // Clear the old arena
    arena.length = 0;
    arena.push(...newArena);
    
    // Update canvas size
    canvas.width = arenaWidth * 20;
    canvas.height = arenaHeight * 20;
    
    // Reset player position
    playerReset();
    
    // Update the scale to maintain block size
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.scale(20, 20);
  }

  // Initialize pieces array
  const pieces = {
    1: {
      matrix: [
        [0,0,0,0],
        [1,1,1,1],
        [0,0,0,0],
        [0,0,0,0]
      ],
      color: 'cyan'
    },
    2: {
      matrix: [
        [1,0,0],
        [1,1,1],
        [0,0,0]
      ],
      color: 'blue'
    },
    3: {
      matrix: [
        [0,0,1],
        [1,1,1],
        [0,0,0]
      ],
      color: 'orange'
    },
    4: {
      matrix: [
        [1,1],
        [1,1]
      ],
      color: 'yellow'
    },
    5: {
      matrix: [
        [0,1,1],
        [1,1,0],
        [0,0,0]
      ],
      color: 'green'
    },
    6: {
      matrix: [
        [0,1,0],
        [1,1,1],
        [0,0,0]
      ],
      color: 'purple'
    },
    7: {
      matrix: [
        [1,1,0],
        [0,1,1],
        [0,0,0]
      ],
      color: 'red'
    }
  };

  // Add the wall piece to pieces array
  pieces[8] = {
    matrix: [[1]],
    color: '#888888' // Gray color for wall blocks
  };

  // Initialize arena with level 1 dimensions
  const arena = createArena(arenaWidth, arenaHeight);

  // The queue of next pieces (IDs)
  const nextPieces = [];
  const nextQueueSize = 5;

  // Initialize nextPieces queue
  function fillNextQueue() {
    while(nextPieces.length < nextQueueSize) {
      nextPieces.push(randomPieceID());
    }
  }

  function randomPieceID() {
    return Math.floor(Math.random() * 7) + 1;
  }

  // Cached piece
  let cachedPiece = null;
  let cachedDiscardUsed = false; // one discard per cached piece

  // Player object
  const player = {
    pos: {x: 4, y: 0},
    matrix: null,
    color: null,
    id: 0
  };

  // Spawn a piece from the front of nextPieces queue
  function playerReset() {
    fillNextQueue();
    const id = nextPieces.shift();
    fillNextQueue();

    player.id = id;
    player.matrix = pieces[id].matrix;
    player.color = pieces[id].color;
    player.pos.y = 0;
    player.pos.x = Math.floor((arenaWidth - player.matrix[0].length) / 2);

    cachedDiscardUsed = false; // reset discard usage on new piece

    if (collide(arena, player)) {
      // Game over
      alert('Game Over! Score: ' + score);
      // Stop the game loop
      if (dropInterval) {
        clearInterval(dropInterval);
        dropInterval = null;
      }
      // Show start screen
      document.getElementById('start-screen').style.display = 'flex';
    }
  }

  // Drawing helpers (rounded connected blocks)
  function drawConnectedBlock(x, y, width, height, radius, color, edges, context=ctx) {
    context.fillStyle = color;
    context.beginPath();

    context.moveTo(x + (edges.left ? radius : 0), y);
    context.lineTo(x + width - (edges.right ? radius : 0), y);
    if (edges.right) context.quadraticCurveTo(x + width, y, x + width, y + (edges.top ? radius : 0));
    else context.lineTo(x + width, y);

    context.lineTo(x + width, y + height - (edges.bottom ? radius : 0));
    if (edges.bottom) context.quadraticCurveTo(x + width, y + height, x + width - (edges.right ? radius : 0), y + height);
    else context.lineTo(x + width, y + height);

    context.lineTo(x + (edges.left ? radius : 0), y + height);
    if (edges.left) context.quadraticCurveTo(x, y + height, x, y + height - (edges.bottom ? radius : 0));
    else context.lineTo(x, y + height);

    context.lineTo(x, y + (edges.top ? radius : 0));
    if (edges.top) context.quadraticCurveTo(x, y, x + (edges.left ? radius : 0), y);
    else context.lineTo(x, y);

    context.closePath();
    context.fill();

    context.lineWidth = 0.05;
    context.strokeStyle = 'black';
    context.stroke();
  }

  function drawMatrix(matrix, offset, color, context=ctx) {
    const rows = matrix.length;
    const cols = matrix[0].length;
    const radius = 0.15;

    for (let y = 0; y < rows; y++) {
      for (let x = 0; x < cols; x++) {
        if (matrix[y][x] !== 0) {
          const top = (y === 0 || matrix[y-1][x] === 0);
          const bottom = (y === rows - 1 || matrix[y+1][x] === 0);
          const left = (x === 0 || matrix[y][x-1] === 0);
          const right = (x === cols - 1 || matrix[y][x+1] === 0);

          drawConnectedBlock(
            x + offset.x,
            y + offset.y,
            1,
            1,
            radius,
            color,
            {top, bottom, left, right},
            context
          );
        }
      }
    }
  }

  function drawArena() {
    for(let y = 0; y < arenaHeight; y++) {
      for(let x = 0; x < arenaWidth; x++) {
        const val = arena[y][x];
        if(val !== 0) {
          const color = pieces[val].color;
          const top = (y === 0 || arena[y-1][x] === 0);
          const bottom = (y === arenaHeight-1 || arena[y+1][x] === 0);
          const left = (x === 0 || arena[y][x-1] === 0);
          const right = (x === arenaWidth-1 || arena[y][x+1] === 0);

          drawConnectedBlock(
            x, y, 1, 1, 0.15, color,
            {top, bottom, left, right}
          );
        }
      }
    }
  }

  function drawGrid() {
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 0.05;

    // Draw vertical lines
    for(let x = 0; x <= arenaWidth; x++) {
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, arenaHeight);
      ctx.stroke();
    }

    // Draw horizontal lines
    for(let y = 0; y <= arenaHeight; y++) {
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(arenaWidth, y);
      ctx.stroke();
    }

    // Highlight the play area
    ctx.strokeStyle = '#666';
    ctx.lineWidth = 0.1;
    ctx.strokeRect(0, 0, arenaWidth, arenaHeight);
  }

  // Draw cached and next piece previews on their canvases
  function drawPreview(ctx, pieceID) {
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    if (!pieceID) return;
    const piece = pieces[pieceID];
    const matrix = piece.matrix;

    // Center the piece in the 4x4 grid (canvas is 4x4 logical units)
    const cols = matrix[0].length;
    const rows = matrix.length;
    // Use floating point for perfect centering
    const offsetX = (4 - cols) / 2;
    const offsetY = (4 - rows) / 2;

    drawMatrix(matrix, {x: offsetX, y: offsetY}, piece.color, ctx);
  }

  // Collision detection
  function collide(arena, player) {
    const m = player.matrix;
    const o = player.pos;
    
    for (let y = 0; y < m.length; y++) {
      for (let x = 0; x < m[y].length; x++) {
        if (m[y][x] !== 0) {
          if (
            o.y + y >= arenaHeight ||
            o.x + x < 0 ||
            o.x + x >= arenaWidth ||
            arena[o.y + y][o.x + x] !== 0
          ) {
            // Consider wall blocks (8) as solid for collision
            return true;
          }
        }
      }
    }
    return false;
  }

  // Merge piece into arena
  function merge(arena, player) {
    player.matrix.forEach((row, y) => {
      row.forEach((value, x) => {
        if (value !== 0) {
          if (player.pos.x + x >= 0 && player.pos.x + x < arenaWidth) {
            arena[player.pos.y + y][player.pos.x + x] = player.id;
          }
        }
      });
    });
  }

  // Clear full rows and return count cleared
  let totalLinesCleared = 0;
  const requiredLinesForExplosion = 30;
  let explosionAvailable = false;

  function updateExplosionBar() {
    const explosionBar = document.getElementById('explosion-bar');
    const progressBar = explosionBar.querySelector('.fill');
    const progress = (totalLinesCleared / requiredLinesForExplosion) * 100;
    progressBar.style.width = progress + '%';
    document.getElementById('lines-text').textContent = 
      totalLinesCleared >= requiredLinesForExplosion ? 
      'READY! Press D!' : 
      `${totalLinesCleared}/30 lines`;
    
    if (totalLinesCleared >= requiredLinesForExplosion && !explosionAvailable) {
      explosionAvailable = true;
      explosionBar.classList.add('ready');
    }
  }

  let firstRowCleared = false;

  function arenaSweep() {
    let rowCount = 0;
    
    outer: for (let y = arenaHeight - 1; y >= 0; y--) {
      for (let x = 0; x < arenaWidth; x++) {
        if (arena[y][x] === 0) {
          continue outer; // skip if not full
        }
      }
      // Remove full row
      const row = arena.splice(y, 1)[0].fill(0);
      arena.unshift(row);
      y++; // recheck same row index after shifting
      rowCount++;
    }

    if (rowCount > 0) {
      // Update score
      if (rowCount === 4) {
        score += 400; // Tetris bonus
      } else {
        score += rowCount * 100; // 100 points per line
      }
      
      // Update big score display
      document.getElementById('score-display').textContent = `SCORE: ${score}`;
      
      totalLinesCleared += rowCount;
      updateExplosionBar();
      
      if (!isRegularMode) {
        updateLevelProgress();
        
        // Check for win condition (completing level 10)
        if (level > 10) {
          // Win condition!
          alert('Congratulations! You completed all levels with ' + score + ' points!');
          // Stop the game loop
          if (dropInterval) {
            clearInterval(dropInterval);
            dropInterval = null;
          }
          // Show start screen
          document.getElementById('start-screen').style.display = 'flex';
          return rowCount;
        }
      }

      // Always keep level 1 in regular mode
      if (isRegularMode) {
        level = 1;
      }

      // Update score display
      document.getElementById('info').innerHTML = 
        '<div>Score: ' + score + (isRegularMode ? '' : ' | Level: ' + level) + '</div>' +
        '<div>Controls: ← → ↓ to move/drop, ↑ to rotate, C to cache/swap, Space for hard drop, L to discard cached (once per game), D for explosion</div>';
    }
    
    return rowCount;
  }

  // Player moves down
  function playerDrop() {
    player.pos.y++;
    if (collide(arena, player)) {
      player.pos.y--;
      merge(arena, player);
      arenaSweep();
      playerReset();
      updatePreviews();
    }
  }

  function playerMove(dir) {
    player.pos.x += dir;
    if (collide(arena, player)) {
      player.pos.x -= dir;
    }
  }

  // Rotate matrix clockwise
  function rotate(matrix) {
    const rows = matrix.length;
    const cols = matrix[0].length;
    const rotated = [];
    for (let x = 0; x < cols; x++) {
      rotated[x] = [];
      for (let y = 0; y < rows; y++) {
        rotated[x][rows - 1 - y] = matrix[y][x];
      }
    }
    return rotated;
  }

  // Rotate player piece with collision correction
  function playerRotate() {
    const rotated = rotate(player.matrix);
    const posX = player.pos.x;
    player.matrix = rotated;

    let offset = 1;
    while (collide(arena, player)) {
      player.pos.x += offset;
      offset = -(offset + (offset > 0 ? 1 : -1));
      if (offset > player.matrix[0].length) {
        player.matrix = rotate(rotate(rotate(rotated)));
        player.pos.x = posX;
        return;
      }
    }
  }

  // Cycle nextPieces forward
  function cycleNextForward() {
    if (nextPieces.length > 1) {
      const first = nextPieces.shift();
      nextPieces.push(first);
      updatePreviews();
    }
  }

  // Cycle nextPieces backward
  function cycleNextBackward() {
    if (nextPieces.length > 1) {
      const last = nextPieces.pop();
      nextPieces.unshift(last);
      updatePreviews();
    }
  }

  // Game-wide flag for one-time cache discard
  let globalCacheDiscardUsed = false;

  // Discard cached piece once per game
  function discardCached() {
    if (!cachedPiece) return;
    if (globalCacheDiscardUsed) {
      // Optional: flash the cached piece preview to indicate it can't be discarded
      const cachedCanvas = document.getElementById('cached');
      cachedCanvas.style.opacity = '0.3';
      setTimeout(() => cachedCanvas.style.opacity = '1', 200);
      return;
    }
    cachedPiece = null;
    globalCacheDiscardUsed = true;
    cachedDiscardUsed = true;
    updatePreviews();
  }

  // Swap cached piece with current player piece
  function swapCached() {
    if (!cachedPiece) {
      cachedPiece = {id: player.id, matrix: player.matrix, color: player.color};
      playerReset();
    } else {
      const temp = cachedPiece;
      cachedPiece = {id: player.id, matrix: player.matrix, color: player.color};
      player.id = temp.id;
      player.matrix = temp.matrix;
      player.color = temp.color;
      player.pos.y = 0;
      player.pos.x = Math.floor((arenaWidth - player.matrix[0].length) / 2);
    }
    cachedDiscardUsed = false;
    updatePreviews();
  }

  // Draw everything
  function draw() {
    // Always reset transform before drawing
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.scale(20, 20);
    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    drawGrid();
    drawArena();
    if (player.matrix) {
      // Draw ghost piece first so it appears behind the actual piece
      drawGhostPiece();
      // Draw actual piece
      drawMatrix(player.matrix, player.pos, player.color);
    }
  }

  function updatePreviews() {
    drawPreview(cachedCtx, cachedPiece ? cachedPiece.id : null);
    drawPreview(nextCtx, nextPieces[0]);
  }

  // Explosion animation state
  let explosionAnimating = false;

  // Determine up to 4 lines below the current player piece and animate a "big boom"
  function blowUpLinesBelow() {
    if (explosionAnimating) return; // avoid re-triggering while animating

    const startY = player.pos.y + (player.matrix ? player.matrix.length : 0);
    const lines = [];
    for (let i = 0; i < 4; i++) {
      const y = startY + i;
      if (y >= 0 && y < arenaHeight) {
  // Always include the row so the explosion always triggers visually
  lines.push(y);
      }
    }
    if (lines.length === 0) return;
    startExplosionAnimation(lines);
  }

  // Start a non-blocking explosion animation over the specified rows.
  function startExplosionAnimation(lines) {
    explosionAnimating = true;

    // Build particle list from every non-empty cell in the selected lines
    const particles = [];
    for (const y of lines) {
      for (let x = 0; x < arenaWidth; x++) {
        const val = arena[y][x];
        const occupied = val !== 0;
        const baseColor = occupied ? (pieces[val].color || 'white') : (Math.random() > 0.5 ? 'orange' : 'yellow');
        const count = occupied ? 12 : 6; // more particles for occupied cells
        for (let i = 0; i < count; i++) {
          const angle = Math.random() * Math.PI * 2;
          const speed = (occupied ? 1.6 : 1.0) + Math.random() * (occupied ? 2.4 : 1.6);
          particles.push({
            x: x + 0.5,
            y: y + 0.5,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed - (Math.random() * 1.2),
            life: 30 + Math.floor(Math.random() * 30),
            age: 0,
            color: baseColor
          });
        }
      }
    }

    // Add a couple shockwave objects (one per line) for the "big boom" feel
    const shocks = lines.map(y => ({ x: arenaWidth / 2, y: y + 0.5, r: 0, alpha: 1 }));

    function step() {
      // Update physics
      for (const p of particles) {
        p.vy += 0.06; // gravity
        p.x += p.vx * 0.18;
        p.y += p.vy * 0.18;
        p.age++;
      }
      for (const s of shocks) {
        s.r += 0.9 + Math.random() * 0.6;
        s.alpha -= 0.02;
      }

      // Render scene (draw board first so explosion overlays it)
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawGrid();
      drawArena();
      if (player.matrix) drawMatrix(player.matrix, player.pos, player.color);

      // Particle layer
      ctx.save();
      for (const p of particles) {
        const alive = p.age < p.life;
        if (!alive) continue;
        const t = 1 - p.age / p.life; // 1 -> 0
        ctx.globalAlpha = Math.max(0, t);
        // draw glow circle
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 0.08 + (1 - t) * 0.45, 0, Math.PI * 2);
        ctx.fill();
      }

      // Shockwave rings
      ctx.globalAlpha = 0.9;
      ctx.lineWidth = 0.06;
      for (const s of shocks) {
        ctx.globalAlpha = Math.max(0, s.alpha * 0.9);
        ctx.strokeStyle = 'orange';
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
        ctx.stroke();
      }
      ctx.restore();

      // Remove dead particles
      for (let i = particles.length - 1; i >= 0; i--) {
        if (particles[i].age >= particles[i].life) particles.splice(i, 1);
      }

      // Continue or finish
      if (particles.length > 0) {
        requestAnimationFrame(step);
      } else {
        // clear the lines now that animation finished
        for (const y of lines) {
          arena[y].fill(0);
        }
        draw();
        explosionAnimating = false;
      }
    }

    requestAnimationFrame(step);
  }

  // Pause/resume drop interval helpers
  function pauseDropInterval() {
    if (dropInterval) {
      clearInterval(dropInterval);
      dropInterval = null;
    }
  }
  function resumeDropInterval() {
    if (!dropInterval) {
      dropInterval = setInterval(() => {
        playerDrop();
        draw();
      }, 1000);
    }
  }

  // Animate the player piece shooting down with flame trail, then explode and clear 4 rows
  function shootDownAndClearTop() {
    if (explosionAnimating) return;
    explosionAnimating = true;

    try {
      pauseDropInterval();

      // Create particles for bottom 4 rows
      const particles = [];
      const shockwaves = [];

      // Create explosion particles for bottom 4 rows
      const fullWidth = arenaWidth + (arenaOffset * 2);
      for (let y = arenaHeight - 4; y < arenaHeight; y++) {
        for (let x = 0; x < fullWidth; x++) {
          const val = arena[y][x];
          const color = val !== 0 ? pieces[val].color : '#FFA500';
          
          // More particles for occupied cells
          const particleCount = val !== 0 ? 15 : 8;
          
          for (let i = 0; i < particleCount; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 1.5 + Math.random() * 2;
            // Adjust x position by subtracting arenaOffset to match game coordinates
            const gameX = x - arenaOffset;
            particles.push({
              x: gameX + 0.5,
              y: y + 0.5,
              vx: Math.cos(angle) * speed,
              vy: Math.sin(angle) * speed - Math.random() * 2,
              life: 40 + Math.floor(Math.random() * 20),
              age: 0,
              color: color,
              size: 0.15 + Math.random() * 0.2
            });
          }
        }
        
        // Add shockwave for each row
        shockwaves.push({
          x: arenaWidth / 2,
          y: y + 0.5,
          r: 0,
          alpha: 1,
          speed: 0.6 + Math.random() * 0.4
        });
      }

      let animationFrame = 0;
      const totalFrames = 45;
      const blocksFalling = [];

      // Prepare blocks that need to fall
      for (let y = arenaHeight - 5; y >= 0; y--) {
        for (let x = 0; x < arenaWidth; x++) {
          if (arena[y][x] !== 0) {
            blocksFalling.push({
              x: x,
              startY: y,
              targetY: y + 4,
              val: arena[y][x],
              progress: 0
            });
          }
        }
      }

      function animate() {
        if (animationFrame >= totalFrames) {
          // Animation complete, move all blocks down
          for (let y = arenaHeight - 1; y >= 4; y--) {
            arena[y].fill(0);
            if (y >= 4) {
              for (let x = 0; x < arenaWidth; x++) {
                arena[y][x] = arena[y - 4][x];
              }
            }
          }
          // Clear top 4 rows
          for (let y = 0; y < 4; y++) {
            arena[y].fill(0);
          }
          
          explosionAnimating = false;
          draw();
          resumeDropInterval();
          return;
        }

        // Clear canvas
        ctx.fillStyle = 'black';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        drawGrid();

        // Draw arena state during transition
        for (let y = 0; y < arenaHeight - 4; y++) {
          for (let x = 0; x < arenaWidth; x++) {
            const val = arena[y][x];
            if (val !== 0) {
              const block = blocksFalling.find(b => b.x === x && b.startY === y);
              if (block) {
                const progress = Math.min(1, animationFrame / totalFrames);
                const currentY = block.startY + (block.targetY - block.startY) * progress;
                drawConnectedBlock(
                  x, currentY, 1, 1, 0.15, pieces[val].color,
                  {top: true, bottom: true, left: true, right: true}
                );
              }
            }
          }
        }

        // Update and draw particles
        ctx.save();
        particles.forEach((p, i) => {
          p.vy += 0.15; // gravity
          p.x += p.vx * 0.15;
          p.y += p.vy * 0.15;
          p.age++;

          if (p.age < p.life) {
            const alpha = 1 - (p.age / p.life);
            ctx.globalAlpha = alpha;
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size * (1 + (1 - alpha)), 0, Math.PI * 2);
            ctx.fill();
          } else {
            particles.splice(i, 1);
          }
        });

        // Update and draw shockwaves
        shockwaves.forEach((s, i) => {
          s.r += s.speed;
          s.alpha -= 0.02;

          if (s.alpha > 0) {
            ctx.globalAlpha = s.alpha;
            ctx.strokeStyle = '#FFA500';
            ctx.lineWidth = 0.1;
            ctx.beginPath();
            ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
            ctx.stroke();
          } else {
            shockwaves.splice(i, 1);
          }
        });
        ctx.restore();

        animationFrame++;
        requestAnimationFrame(animate);
      }

      requestAnimationFrame(animate);
    } catch (err) {
      console.error('Error during explosion animation:', err);
      explosionAnimating = false;
      resumeDropInterval();
    }
  }

  // Draw everything
  function clearTopLines() {
    for (let y = 0; y < 4; y++) {
      if (arena[y].some(cell => cell !== 0)) {
        arena[y].fill(0);
      }
    }
    draw();
  }  // Event handlers
  // Make startGame function globally available
  window.startGame = function() {
    console.log('Starting game...');
    
    // Hide start screen
    document.getElementById('start-screen').style.display = 'none';
    
    // Get selected level
    level = parseInt(document.getElementById('level-select').value);
    
    // Reset game state
    score = 0;
    totalLinesCleared = 0;
    explosionAvailable = false;
    globalCacheDiscardUsed = false;
    cachedPiece = null;
    
    // Clear any existing intervals
    if (dropInterval) {
      clearInterval(dropInterval);
    }

    try {
      // Setup the selected level
      setupLevel(level);
      
      // Initialize game pieces
      fillNextQueue();
      playerReset();
      updatePreviews();
      
      // Reset progress bars
      document.querySelector('#explosion-bar .fill').style.width = '0%';
      document.querySelector('#explosion-bar .fill').style.animation = 'none';
      document.getElementById('lines-text').textContent = '0/30 lines';
      
      // Update level progress display
      updateLevelProgress();
      
      // Start game loop with fixed speed
      dropInterval = setInterval(() => {
        playerDrop();
        draw();
      }, 1000);
      
      // Initial draw
      draw();
    } catch (error) {
      console.error('Error starting game:', error);
    }
  };

  window.addEventListener('keydown', event => {
    if(event.key === 'ArrowLeft') {
      playerMove(-1);
      draw();
    }
    else if(event.key === 'ArrowRight') {
      playerMove(1);
      draw();
    }
    else if(event.key === 'ArrowDown') {
      playerDrop();
      draw();
    }
    else if(event.key === 'ArrowUp') {
      playerRotate();
      draw();
    }
    else if(event.key.toLowerCase() === 'c') {
      // C: cache/swap current piece
      swapCached();
      draw();
    }
    else if(event.key === ' ' || event.code === 'Space') {
      // Space: hard drop
      while (!collide(arena, player)) {
        player.pos.y++;
      }
      player.pos.y--; // step back to last valid
      merge(arena, player);
      arenaSweep();
      playerReset();
      updatePreviews();
      draw();
    }
    else if(event.key.toLowerCase() === 'l') {
      discardCached();
      draw();
    }
    else if(event.key.toLowerCase() === 'd') {
      if (explosionAvailable) {
        shootDownAndClearTop();
        // Reset progress after explosion
        explosionAvailable = false;
        totalLinesCleared = 0;
        document.querySelector('#explosion-bar .fill').style.animation = 'none';
        document.querySelector('#explosion-bar .fill').style.width = '0%';
        document.getElementById('lines-text').textContent = '0/30 lines';
      }
    }
  });

  let dropInterval;
  let gameSpeed = 1000; // default speed
  let showGhostPiece = true;
  let linesCleared = 0;

  function updateLevelProgress() {
    if (isRegularMode) {
      // Hide level bar and only show controls in regular mode
      document.getElementById('level-bar').style.display = 'none';
      document.getElementById('info').innerHTML = 
        '<div>Controls: ← → ↓ to move/drop, ↑ to rotate, C to cache/swap, Space for hard drop, L to discard cached (once per game), D for explosion</div>';
      return;
    }

    // Challenge mode: show level progress
    document.getElementById('level-bar').style.display = 'block';
    const currentConfig = levelConfig[level];
    const progress = (score / currentConfig.scoreTarget) * 100;
    
    // Update level progress bar
    document.querySelector('#level-bar .fill').style.width = progress + '%';
    document.getElementById('level-text').textContent = 
      `Level ${level} - ${score}/${currentConfig.scoreTarget}`;
    
    // Update game info display for challenge mode
    document.getElementById('info').innerHTML = 
      `<div style="text-align: left; margin-bottom: 4px;">Level: ${level}</div>` +
      '<div>Controls: ← → ↓ to move/drop, ↑ to rotate, C to cache/swap, Space for hard drop, L to discard cached (once per game), D for explosion</div>';    // Check for level completion
    if (score >= currentConfig.scoreTarget) {
      if (level === 5) {
        // Game complete!
        showNotification('Congratulations! You\'ve completed all levels!');
        if (dropInterval) {
          clearInterval(dropInterval);
          dropInterval = null;
        }
        setTimeout(() => {
          document.getElementById('start-screen').style.display = 'flex';
        }, 2000);
      } else {
        // Advance to next level
        showNotification(`Going to Level ${level + 1}`);
        level++;
        score = 0;
        setTimeout(() => {
          setupLevel(level);
        }, 1000);
      }
    }
  }
  
  function setupLevel(newLevel) {
    const config = levelConfig[newLevel];
    
    // Update dimensions
    arenaWidth = config.width;
    arenaHeight = config.height;
    
    // Create new arena
    const newArena = createArena(arenaWidth, arenaHeight);
    
    // Apply level-specific grid setup
    config.setupGrid(newArena);
    
    // Update the arena
    arena.length = 0;
    arena.push(...newArena);
    
    // Update canvas size and scale
    canvas.width = arenaWidth * 20;
    canvas.height = arenaHeight * 20;
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.scale(20, 20);
    
    // Update previews canvas sizes if needed for wider grid
    if (arenaWidth > initialWidth) {
      cachedCanvas.width = 80;
      cachedCanvas.height = 80;
      nextCanvas.width = 80;
      nextCanvas.height = 80;
      cachedCtx.setTransform(1, 0, 0, 1, 0, 0);
      nextCtx.setTransform(1, 0, 0, 1, 0, 0);
      cachedCtx.scale(20, 20);
      nextCtx.scale(20, 20);
    }
    
    // Center the player's starting position
    player.pos.x = Math.floor((arenaWidth - (player.matrix ? player.matrix[0].length : 0)) / 2);
    player.pos.y = 0;
    
    // Update level progress display
    updateLevelProgress();
  }

  function showNotification(text) {
    const notification = document.getElementById('level-notification');
    notification.textContent = text;
    notification.style.opacity = '1';
    setTimeout(() => {
      notification.style.opacity = '0';
    }, 1500);
  }

  function toggleSettings() {
    const panel = document.getElementById('settings-panel');
    panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
  }

  function updateGameSpeed() {
    const speedSelect = document.getElementById('game-speed');
    gameSpeed = parseInt(speedSelect.value);
    if (dropInterval) {
      clearInterval(dropInterval);
      dropInterval = setInterval(() => {
        playerDrop();
        draw();
      }, gameSpeed);
    }
  }

  function toggleGhostPiece() {
    showGhostPiece = document.getElementById('ghost-toggle').checked;
    draw();
  }

  function getGhostPosition() {
    const ghost = {
      pos: { x: player.pos.x, y: player.pos.y },
      matrix: player.matrix
    };

    while (!collide(arena, ghost)) {
      ghost.pos.y++;
    }
    ghost.pos.y--;

    return ghost;
  }

  function drawGhostPiece() {
    if (!showGhostPiece || !player.matrix) return;
    
    const ghost = getGhostPosition();
    const originalAlpha = ctx.globalAlpha;
    ctx.globalAlpha = 0.2;
    drawMatrix(ghost.matrix, ghost.pos, player.color);
    ctx.globalAlpha = originalAlpha;
  }

  let isRegularMode = true;

  function selectMode(mode) {
    isRegularMode = mode === 'regular';
    const regularBtn = document.getElementById('regular-mode');
    const challengeBtn = document.getElementById('challenge-mode');
    const levelSelection = document.getElementById('level-selection');

    if (isRegularMode) {
      regularBtn.style.background = '#FFA500';
      regularBtn.style.color = 'black';
      challengeBtn.style.background = 'transparent';
      challengeBtn.style.color = '#FFA500';
      levelSelection.style.display = 'none';
    } else {
      challengeBtn.style.background = '#FFA500';
      challengeBtn.style.color = 'black';
      regularBtn.style.background = 'transparent';
      regularBtn.style.color = '#FFA500';
      levelSelection.style.display = 'block';
    }
  }

  function startGame() {
    // Hide start screen
    document.getElementById('start-screen').style.display = 'none';
    
    // Reset game state
    score = 0;
    totalLinesCleared = 0;
    explosionAvailable = false;
    globalCacheDiscardUsed = false;
    cachedPiece = null;
    
    // Clear any existing intervals
    if (dropInterval) {
      clearInterval(dropInterval);
    }

    if (isRegularMode) {
      // Setup regular mode with standard 10x20 grid
      arenaWidth = 10;
      arenaHeight = 20;
      level = 1; // Always stay at level 1 for regular mode
      
      // Create a regular Tetris grid with no obstacles
      const newArena = createArena(arenaWidth, arenaHeight);
      arena.length = 0;
      arena.push(...newArena);
      
      // Update canvas size for standard Tetris grid
      canvas.width = arenaWidth * 20;
      canvas.height = arenaHeight * 20;
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.scale(20, 20);

      // Hide level progress bar and level display
      document.getElementById('level-bar').style.display = 'none';
    } else {
      // Challenge mode - setup the selected level
      level = parseInt(document.getElementById('level-select').value);
      setupLevel(level);
      document.getElementById('level-bar').style.display = 'block';
      updateLevelProgress();
    }
    
    // Initialize game pieces
    fillNextQueue();
    playerReset();
    updatePreviews();
    
    // Reset explosion bar
    document.querySelector('#explosion-bar .fill').style.width = '0%';
    document.querySelector('#explosion-bar .fill').style.animation = 'none';
    document.getElementById('lines-text').textContent = '0/30 lines';
    
    // Start game loop with fixed speed
    dropInterval = setInterval(() => {
      playerDrop();
      draw();
    }, 1000);
    
    // Initial draw
    draw();
  }

  // Initialize the game when the document is fully loaded
  document.addEventListener('DOMContentLoaded', function() {
    // Initialize game state
    fillNextQueue();
    updatePreviews();
    draw();

    // Initialize score display
    document.getElementById('info').innerHTML = 
      '<div>Score: 0 | Level: 1</div>' +
      '<div>Controls: ← → ↓ to move/drop, ↑ to rotate, C to cache/swap, Space for hard drop, L to discard cached (once per game), D for explosion</div>';

    // Make sure start screen is visible initially
    document.getElementById('start-screen').style.display = 'flex';
    
    // Initialize settings
    document.getElementById('game-speed').value = '1000';
    document.getElementById('ghost-toggle').checked = true;
  });
</script>
</body>
</html>
